학습 일자 : 2022.05.03

---

## 운영체제

### 운영체제의 정의

운영체제(OS: Operating System)는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공

_BIOS(Basic Input Output System)_  
_ROM(Read Only Memory)_  
_RAM(Random Access Memory)_

### 운영체제의 목적

운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있음  
처리 능력, 반환 시간, 사용 가능도, 신뢰도는 운영체제의 성능을 평가하는 기준이 됨

- 처리 능력(Throughtput) : 일정 시간 내에 시스템이 처리하는 일의 양
- 반환 시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- 사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- 신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도

### 운영체제의 기능

- 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입·출력장치, 파일 및 정보 등의 자원을 관리
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공
- 사용자와 시스템 간의 편리한 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리·제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류를 검사하고 복구
- 자원 보호 기능을 제공
- 입·출력에 대한 보조 기능을 제공
- 가상 계산기 기능을 제공

_프로세스: 지금 현재 실행중인 프로그램_  
_프로세서: CPU_

### Windows

windows는 1990년대 마이크로소프트(Microsoft)사가 개발한 운영체제
Windows의 주요 특징

- 그래픽 사용자 인터페이스(GUI: Graphic User Interface)
  키보드로 명령어를 직접 입력하지 않고 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식
- 선점형 멀티태스킹(Preemptive Multi-Tasking)
  동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
- PnP(Plug and Play, 자동 감지 기능)
  컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능
- OLE(Object Linking and Embedding)
  다른 여러 응용프로그램에서 작성된 문서나 그림 등의 개체(Objext)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능
- 255자의 긴 파일명
  - Windows에서는 파일 이름을 지정할 때 VFAT(Virtual File Allocation Table)를 이용하여 최대 255자까지 지정할 수 있음
  - 파일 이름으로는 \ / : \* ? " < > | 를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 지정할 수 있음
- Single-User 시스템
  컴퓨터 한 대를 한 사람만이 독점해서 사용함

_CLI: 명령 줄 인터페이스(Command Line Interface)는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식_

### UNIX

Unix는 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제

- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System)
- 대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음
- 크기가 작고 이해하기가 쉬움
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원
- 많은 네트워킹 기능을 제공하므로 통신망(Network)관리용 운영체제로 적합
- 트리 구조의 파일 시스템을 가짐
- 전문적인 프로그램 개발에 용이
- 다양한 유틸리티 프로그램들이 존재

※ 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)

- 다중 사용자(Multi-User)는 여러 사용자가 동시에 시스템을 사용하는 것
- 다중 작업(Multi-Tasking)은 여러 개의 작업이나 프로그램을 동시에 수행하는 것을 의미
- 하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시에 처리할 수 있음

커널(Kernel)

- UNIX의 가장 핵심적인 부분
- 컴퓨터가 부팅될 대 주기억장치에 적재된 후 상주하면서 실행
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
- 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입·출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행

쉘(Shell)

- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
- 시스템과 사용자 간의 인터페이스를 담당
- DOS의 COMMAND.COM과 같은 기능을 수행
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
- 파이프라인 기능을 지원하고 입·출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있음
- 공용 Shell(Bourne Shell, C Shell, Korn Shell)이나 사용자 자신이 만든 Shell을 사용할 수 있음

Utility Program

- 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용
- DOS에서의 외부 명령어에 해당됨
- 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있음

_MS-DOS: Microsoft Disk Operating System(마이크로소프트 디스크 운영 체제)_

## 기억장치 관리 전략

기억장치의 관리 전략은 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것으로 반입(Fetch)전략, 배치(Placement)전략, 교체(Replacement) 전략이 있음

### 반입(Fetch) 전략

반입 전략은 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적쟇라 것인지를 결정하는 전략
| | |
|---|---|
| 요구 반입(Demand Fetch) | 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법 |
| 예상 반입(Anticipatory Fetch) | 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법 |

### 배치(Placement) 전략

배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
| | |
|---|---|
| 최초 적합(First Fit) | 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 |
| 최적 적합(Best Fit) | 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법 |
| 최악 적합(Worst Fit) | 프로그램이나 데이터가 들어갈수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법 |

_단편화: RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태_
_외부단편화: 메모리가 할당 및 해제 작업의 반복으로 작은 메모리 크기의 중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당 할 수 없는 상황_
_내부단편화: 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상_

### 교체(Replacement) 전략

교체 전략은 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략

- 교체 전략의 종류에는 FIFO, OPT, LRU, LFU, NUR, SCR 등이 있음

### 주기억장치 할당의 개념

주기억장치 할당 기법은 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용이며, 연속 할당 기법과 분산 할당 기법으로 분류할 수 있음

- 연속 할당 기법
  프로그램을 주기억장치에 연속으로 할당하는 기법으로, 단일 분할 할당 기법과 다중 분할 할당 기법이 있음

  - 단일 분할 할당 기법: 오버레이, 스와핑
  - 다중 분할 할당 기법: 고정 분할 할당 기법, 동적 분할 할당 기법

- 분산 할당 기법
  프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법으로, 페이징 기법과 세그먼테이션 기법으로 나눌 수 있음

### 다중 분할 할당 기법

**고정 분할 할당(Multiple contiguous Fixed parTition allocation, MFT)기법 = 정적 할당(Static Allocation)기법**

고정 분할 할당은 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법

- 프로그램을 실행하려면 프로그램 전체가 주기억장치에 위치해야 함
- 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있음
- 일정한 크기의 분할 영역에 다양한 크기의 프로그램이 할당되므로 내부 단편화 및 외부 단편화가 발생하여 주기억장치의 낭비가 많음
- 실행할 프로그램의 크기를 미리 알고 있어야 함
- 다중 프로그래밍을 위해 사용되었으나 현재는 사용되지 않음

**가변 분할 할당(Multiple contiguous Variable parTition allocation, MVT) 기법 = 동적 할당(Dynamic Allocation) 기법**

고정 분할 할당 기법의 단편화를 줄이기 위한 것으로, 미리 주기억장치를 분할해 놓는 것이 아니라 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법

- 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍의 정도를 높일 수 있음
- 고정 분할 할당 기법에 비해 실행될 프로세스 크기에 대한 제약이 적음
- 단편화를 상당 부분 해결할 수 있으나 영역과 영역 사이에 단편화가 발생될 수 있음

### 가상기억장치

가상기억장치는 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의주소를 주기억장치의 주소로 바꾸는 주소 변환 작업이 필요
- 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있음
- 가상기억장치의 일반적인 구현 방법에는 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나눌 수 있음

### 페이징(Paging) 기법

- 페이징 기법은 가상기억장치에 보관되어 있는 **프로그램과 주기억장치의 영역을 동일한 크기**로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
- **프로그램을 일정한 크기로 나눈 단위를 페이지(Page)**라고 하고, **페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)**이라고 함
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 **페이지 맵 테이블(Page Map Table)이 필요**함

### 세그먼테이션(Segmentation) 기법

- 세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 **다양한 크기의 논리적인 단위**로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
- 프로그램을 **배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)**라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 **세그먼트 맵 테이블(Segment Map Table)이 필요**
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음

### 페이지 교체 알고리즘

페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프로엠이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법

- OPT(OPTimal replacement, 최적 교체)

  - **앞으로 가장 오랫동안 사용하지 않을 페이지**를 교체하는 기법
  - 벨레이디(Belady)가 제안한 것으로, **페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘**

- FIFO(First In First Out)

  - 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 **가장 먼저 들어와서 가장 오래 있었던 페이지를 교체**하는 기법
  - 이해하기 쉽고, 프로그래밍 및 설계가 간단함

- LRU(Least Recently Used)

  - **최근에 가장 오랫동안 사용하지 않은 페이지를 교체**하는 기법
  - 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체

- LFU(Least Frequently Used)
  - **사용 빈도가 가장 적은 페이지를 교체**하는 기법
  - 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용됨

SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, **FIFO 기법의 단점을 보완**하는 기법

NUR(Not Used Recently)

- LRU와 비슷한 알고리즘으로, **최근에 사용하지 않은 페이지를 교체**하는 기법
- 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 **참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용**됨

### 페이지 크기

**페이지 크기가 작을 경우**

- 페이지 **단편화가 감소**되고, 한 개의 페이지를 **주기억장치로 이동하는 시간이 줄어듬**
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 **효율적인 워킹 셋을 유지**할 수 있음
- Locality에 더 일치할 수 있기 때문에 **기억장치 효율이 높아짐**
- 페이지 정보를 갖는 **페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어짐**
- 디스크 접근 횟수가 많아져서 **전체적인 입·출력 시간은 늘어남**

**페이지 크기가 클 경우**

- 페이지 정보를 갖는 **페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라짐**
- 디스크 접근 횟수가 줄어들어 **전체적인 입·출력의 효율성이 증가됨**
- 페이지 **단편화가 증가**되고, 한 개의 페이지를 **주기억장치로 이동하는 시간이 늘어남**
- 프로세스(프로그램) 수행에 **불필요한 내용까지도 주기억장치에 적재**될 수 있음

### Locality

Locality(국부성, 지역성, 구역성, 국소성)는 **프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론**

- **스래싱을 방지하기 위한 워킹 셋 이론의 기반**이 됨
- Locality의 종류에는 **시간 구역성(Temporal Locality)과 공간 구역성(Spatial Locality)**이 있음

**시간 구역성(Temporal Locality)**

- 시간 구역성은 프로세스가 실행되면서 **하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상**
- **한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미**
- 시간 구역성이 이루어지는 기억 장소: Loop(반복, 순환), 스택(Stack), 부 프로그램(Sub Routine), Counting(1씩 증감), 집계(To-taling)에 사용되는 변수(기억장소)

**공간 구역성(Spatial Locality)**

- 공간 구역성은 프로세스 실행 시 **일정 위치의 페이지를 집중적으로 액세스 하는 현상**
- **어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미**
- 공간 구역성이 이루어지는 기억장소: 배열 순회(Array Traversal, 배열 순례), 순차적 코드의 실행, 프로그래머들의 관련된 변수(데이터를 저장할 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용

### 워킹 셋(Working Set)

워킹 셋은 **프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합**

- **데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델**로, 프로그램의 **Locality 특징을 이용**
- **자주 참조되는 워킹 셋을 주기억장치에 상주**시킴으로써 **페이지 부재 및 페이지 교체 현상이 줄어**들어 프로세스 기억장치 사용이 안정됨
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 **워킹 셋은 시간에 따라 변경됨**

### 스래싱(Thrashing)

스래싱은 **프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상**

- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 **하나의 프로세스 수행 과정중 자주 페이지 부재가 발생함으로써 나타나는 현상**으로, **전체 시스템의 성능이 저하됨**
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, **다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 됨**
- 스래싱 현상 방지 방법
  - **다중 프로그래밍의 정도를 적정 수준으로 유지**
  - **페이지 부재 빈도(Page Fault Frequency)를 조절하여 사용**
  - **워킹 셋을 유지**
  - **부족한 자원을 증설하고, 일부 프로세스를 중단**
  - **CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영**

※ 페이지 부재(Page Fault)

- 페이지 부재는 프로세스 실행 시 **참조할 페이지가 주기억장치에 없는 현상**이며, **페이지 부재 빈도(PFF; Page Fault Frequency)는 페이지 부재가 일어나는 횟수를 의미**
- **페이지 부재 빈도 방식**: 페이지 부재율(Page Fault Rate)에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 **페이지 부재율을 적정 수준으로 유지하는 방식**

## 프로세스

프로세스는 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며, 작업(Job), 태스크(Task)라고도 함

- 프로세스는 다음과 같이 여러 형태로 정의할 수 있음
  - PCB를 가진 프로그램
  - 실기억장치에 저장된 프로그램
  - 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
  - 프로시저가 활동중인 것
  - 비동기적 행위를 일으키는 주체
  - 지정된 결과를 얻기 위한 일련의 계통적 동작
  - 목적 또는 결과에 따라 발생되는 사건들의 과정
  - 운영체제가 관리하는 실행 단위

_PCB(Process Control Block)_
_프로시저_
_레지스터_

---

학습 일자 : 2022.05.10

---

## Thread

스레드는 프로세스 내에서 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위

- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 함
- 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 함
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능
- 스레드의 분류
  - 사용자 수준의 스레드
    - 사용자가 만든 라이브러리를 사용하여 스레드를 운용
    - 속도는 빠르지만 구현이 어려움
  - 커널 수준의 스레드
    - 운영체제의 커널에 의해 스레드를 운용
    - 구현이 쉽지만 속도가 느림
- 스레드 사용의 장점
  - 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있음
  - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있음
  - 응용 프로그램의 응답 시간(Response Time)을 단축시킬 수 있음
  - 실행 환경을 공유시켜 기억장소의 낭비가 줄어듬
  - 프로세스들 간의 통신이 향상됨
  - 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신함

## 스케줄링 / 문맥 교환

### 스케줄링의 정의

스케줄링(Scheduling)은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미

### 스케줄링의 목적

- 공정성
- 처리율(량) 증가
- CPU 이용률 증가
- 우선순위 제도
- 오버헤드 최소화
- 응답 시간(Response Time, 반응 시간) 최소화
- 반환 시간(Turn Around Time) 최소화
- 대기 시간 최소화
- 균형 있는 자원의 사용
- 무한 연기 회피

### 문맥 교환

- 문맥 교환은 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것
- 새로운 프로세스에 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보를 저장
- 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행되도록 함  
  ※ 스케줄링의 성능 평가 기준 : 스케줄링의 목적 중 CPU 이용률, 처리율, 반환 시간, 대기 시간, 응답 시간은 여러 종류의 스케줄링 성능을 비교하는 기준이 됨

### 비선점(Non-Preemptive) 스케줄링

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
- 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용
- 모든 프로세스에 대한 요구를 공정하게 처리할 수 있음
- 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합
- 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있음
- 비선점 스케줄링의 종류에는 FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘이 있음

### 선점(Preemptive) 스케줄링

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
- 우선순위가 높은 프로세스를 빠르게 처리할 수 있음
- 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용
- 많은 오버헤드(Overhead)를 초래
- 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록(Clock)이 필요
- 선점 스케줄링의 종류에는 Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있음

### FCFS(First Come First Service, 선입 선출) = FIFO(First In First Out)

FCFS는 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당한느 기법으로, 가장 간단한 알고리즘

- 먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨

### SJF(Shortest Job First, 단기 작업 우선)

SJF는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법

- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘

### HRN(Hightest Response-ratio Next)

실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법

- 우선순위 계산 공식을 이용하여 서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아짐
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
- 우선순위 계산식  
  $우선순위\,계산식\,=\, \frac {대기\,시간\,+\,서비스\,시간} {서비스\,시간}$

### Windows의 주요 환경 변수

Windows에서 환경 변수 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 '%'를 입력해야 함

- Windows에서 set을 입력하면 모든 환경 변수와 값을 출력
  | 환경 변수 | 용도 |
  |---|---|
  | %ALLUSERPROFILE% | 모든 사용자의 프로필이 저장된 폴더 |
  | %APPDATA% | 설치된 프로그램의 필요 데이터가 저장된 폴더 |
  | %ComSpec% | 기본 명령 프롬프트로 사용할 프로그램명 |
  | %HOMEDRIVE% | 로그인한 계정의 정보가 저장된 드라이브 |
  | %HOMEPATH% | 로그인한 계정의 기본 폴더 |
  | %LOGONSERVER% | 로그인한 계정이 접속한 서버명 |
  | %PATH% | 실행 파일을 찾는 경로 |
  | %PATHEXT% | cmd에서 실행할 수 있는 파일의 확장자 목록 |
  | %ProgramFiles% | 기본 프로그램의 설치 폴더 |
  | %SYSTEMDRIVE% | Windows가 부팅된 드라이브 |
  | %SYSTEMROOT% | 부팅된 운영체제가 들어 있는 폴더 |
  | %TEMP% 또는 %TMP% | 임시 파일이 저장되는 폴더 |
  | %USERDOMAIN% | 로그인한 시스템의 도메인명 |
  | %USERNAME% | 로그인한 계정 이름 |
  | %USERPROFILE% | 로그인한 유저의 프로필이 저장된 폴더명 |

### UNIX / LINUX의 주요 환경 변수

UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 '$'를 입력해야 함

- UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시함
  | 환경 변수 | 용도 |
  |---|---|
  | $DISPLAY | 현재 X 윈도 디스플레이 위치 |
  | $HOME | 사용자의 홈 디렉터리 |
  | $LANG | 프로그램 사용 시 기본적으로 지원되는 언어 |
  | $MAIL | 메일을 보관하는 경로 |
  | $PATH | 실행 파일을 찾는 경로 |
  | $PS1 | 쉘 프롬프트 정보 |
  | $PWD | 현재 작업하는 디렉터리 |
  | $TERM | 로긴 터미널 타입 |
  | $USER | 사용자의 이름 |

### Windows 기본 명령어

| 명령어 | 기능                                      |
| ------ | ----------------------------------------- |
| DIR    | 파일 목록을 표시                          |
| COPY   | 파일을 복사                               |
| TYPE   | 파일의 내용을 표시                        |
| REN    | 파일의 이름을 변경                        |
| DEL    | 파일을 삭제                               |
| MD     | 디렉터리를 생성                           |
| CD     | 디렉터리의 위치를 변경                    |
| CLS    | 화면의 내용을 지움                        |
| ATTRIB | 파일의 속성을 변경                        |
| FIND   | 파일 찾기                                 |
| CHKDSK | 디스크 상태를 점검                        |
| FORMAT | 디스크 표면을 트랙과 섹터로 나누어 초기화 |
| MOVE   | 파일을 이동                               |

### UNIX / LINUX 기본 명령어

| 명령어        | 기능                                                                                           |
| ------------- | ---------------------------------------------------------------------------------------------- |
| cat           | 파일 내용을 화면에 표시                                                                        |
| chdir         | 현재 사용할 디렉터리의 위치를 변경                                                             |
| chmod         | 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정                                            |
| chown         | 소유자를 변경                                                                                  |
| cp            | 파일을 복사                                                                                    |
| exec          | 새로운 프로세스를 수행                                                                         |
| find          | 파일 찾기                                                                                      |
| fork          | 새로운 프로세스를 생성(하위 프로세스 호출, 프로세스 복제 명령)                                 |
| fsck          | 파일 시스템을 검사하고 보수                                                                    |
| getpid        | 자신의 프로세스 아이디를 얻음                                                                  |
| getppid       | 부모 프로세스 아이디를 얻음                                                                    |
| ls            | 현재 디렉터리 내의 파일 목록을 확인                                                            |
| mount/unmount | 파일 시스템을 마운팅/마운팅해제                                                                |
| rm            | 파일을 삭제                                                                                    |
| wait          | fork 후 exec에 의해 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림 |

---

학습 일자 : 2022.05.12

---

### LINUX 파일 접근 권한

d rwx rwx rwx
d(-) : 파일 형식(-: 파일, d: 디렉터리)
r: 읽을 수 있는 권한
w: 내용을 변경할 수 있는 권한
x: 실행할 수 있는 권한
-: 권한이 없음

파일의 권한은 소유자(u{user}) , 그룹(g{group}), 그외 사람들(o{other}) 순으로 각 3칸씩 이렇게 총 9 칸이 있음

rwx는 2진수로 표현할 수 있음
rwx: 7
rw-: 6
r-x: 5
r--: 4
-wx: 3
-w-: 2
--x: 1
